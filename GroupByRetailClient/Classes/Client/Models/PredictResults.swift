//
// PredictResults.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Prediction result including list of recommendations based on provided inputs. */
public struct PredictResults: Codable, JSONEncodable, Hashable {

    /** Warnings collected with validation and Recommendations AI API issues. */
    public var warnings: [AnyCodable]?
    /** Recommendations built by Recommendations AI model. */
    public var products: [[String: AnyCodable]]?
    /** Recommendations built by Recommendations AI model. */
    public var records: [[String: AnyCodable]]?
    /** Model Id used for predictions */
    public var modelId: String?
    /** Model Name used for predictions */
    public var modelName: String?
    /**   Currently supported values:   `recommended-for-you`   `others-you-may-like`,   `frequently-bought-together`   `page-optimization`   `similar-items`,   `buy-it-again`   `on-sale-items`   `recently-viewed`    This field together with optimization_objective describe model metadata to use to control model training and   serving. See https://cloud.google.com/retail/docs/models for more details.  */
    public var modelType: String?
    /**   Currently supported values: `ctr`, `cvr`, `revenue-per-order`.     If not specified, we choose default based on model type. Default depends on type of recommendation:   `recommended-for-you` => `ctr`   `others-you-may-like` => `ctr`   `frequently-bought-together` => `revenue_per_order`    This field together with modelType describe model metadata to use to control model training and serving.   See https://cloud.google.com/retail/docs/models for more details on what the model metadata control and which   combination of parameters are valid.  */
    public var optimizationObjective: String?
    /** Filter set applied to the recommendation */
    public var filterSet: String?
    /** RawFilter applied to the recommendation */
    public var rawFilter: String?
    /** Filters applied to the recommendation */
    public var filters: [FilterParameter]?
    public var metadata: AnyCodable?

    public init(warnings: [AnyCodable]? = nil, products: [[String: AnyCodable]]? = nil, records: [[String: AnyCodable]]? = nil, modelId: String? = nil, modelName: String? = nil, modelType: String? = nil, optimizationObjective: String? = nil, filterSet: String? = nil, rawFilter: String? = nil, filters: [FilterParameter]? = nil, metadata: AnyCodable? = nil) {
        self.warnings = warnings
        self.products = products
        self.records = records
        self.modelId = modelId
        self.modelName = modelName
        self.modelType = modelType
        self.optimizationObjective = optimizationObjective
        self.filterSet = filterSet
        self.rawFilter = rawFilter
        self.filters = filters
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case warnings
        case products
        case records
        case modelId
        case modelName
        case modelType
        case optimizationObjective
        case filterSet
        case rawFilter
        case filters
        case metadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(warnings, forKey: .warnings)
        try container.encodeIfPresent(products, forKey: .products)
        try container.encodeIfPresent(records, forKey: .records)
        try container.encodeIfPresent(modelId, forKey: .modelId)
        try container.encodeIfPresent(modelName, forKey: .modelName)
        try container.encodeIfPresent(modelType, forKey: .modelType)
        try container.encodeIfPresent(optimizationObjective, forKey: .optimizationObjective)
        try container.encodeIfPresent(filterSet, forKey: .filterSet)
        try container.encodeIfPresent(rawFilter, forKey: .rawFilter)
        try container.encodeIfPresent(filters, forKey: .filters)
        try container.encodeIfPresent(metadata, forKey: .metadata)
    }
}

